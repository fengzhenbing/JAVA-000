结果总结如下

|  | UseSerialGC | UseParallelGC | UseConcMarkSweepGC | UseG1GC |
|:------------|:--------------|:-------------------|:--------|:---|
| 512m       |    10093      |        9201            |   11456      |  11905  |
| 1g       |     14717     |        15225            |      15877   |   15104 |
| 2g       |     13082     |         15829           |    14380     |  15415  |
| 4g       |      12428    |          14700          |    12784     |  15529  |

环境
mac系统
`
java version "1.8.0_231"
Java(TM) SE Runtime Environment (build 1.8.0_231-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)
`

#### 自我总结：
  -   SerialGC  新生代：复制算法 老年代：标记整理； 为单线程的，在小内存时，效果和其他gc相比，性能相差不多，随着内存增大，cpu内核数增大，性能下降趋势， 一般server模式不考虑使用
  -   并行GC  新生代：复制算法 老年代：标记整理； 在4g以下堆内存，吞吐量较高，但在大内存下，一次gc要清理的对象比较多，可能STW时间也会增大，性能会有所下降，重吞吐量4g以下内存考虑使用
  -  CMS GC  新生代：复制算法 老年代：标记清除； 延迟小，重视延迟小的场景4g一下考虑使用
  -  G1 GC    标记整理+复制；  采用网格化的分配堆内存，延迟比并行小，4g以上大内存的考虑使用，


#### 课堂上讲的知道原则：
  选择正确的 GC 算法，根据使用场景不断尝试:
 -  如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC;
 -  如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC;
 -  如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。 对于内存大小的考量:
 -  一般 4G 以上，算是比较大，用 G1 的性价比较高。
 -   一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。
